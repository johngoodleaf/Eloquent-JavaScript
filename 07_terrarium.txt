:chap_num: 7
:prev_link: 06_object
:next_link: 08_FIXME
:load_files: []

= Practical: Terrarium =

FIXME

== Building an Ecosystem Simulation ==

(((terrarium example|()))
In this chapter, we are going to build a virtual terrarium, a tank
with insects moving around in it. We will build objects that model
the terrarium and the creatures inside it, and we will write methods for
those objects to ``animate'' the creatures and allow them (turn by
turn) to live their lives.

== Defining the Terrarium ==

We take a rather simple approach and make the terrarium a
two-dimensional grid. On this grid there are a number of bugs. When
the terrarium is activated, all the bugs get a chance to take an
action, such as moving, which changes the state of the terrarium.

(((discretization)))(((simulation)))
Thus, we chop both time and space into units with a fixed
size---squares for space; ``turns'' for time. This usually makes
things easier to model in a program. Of course, it has the drawback of
being inaccurate. Fortunately, this terrarium-simulator is not
required to be accurate in any way, and we can safely cut corners.

A terrarium can be defined with a ``plan,'' which is an array of
strings. We could have used a single string, but the array structure
nicely reflects the two-dimensional structure of the data.


[source,javascript]
----
var thePlan =
  ["############################",
   "#      #    #      o      ##",
   "#                          #",
   "#          #####           #",
   "##         #   #    ##     #",
   "###           ##     #     #",
   "#           ###      #     #",
   "#   ####                   #",
   "#   ##       o             #",
   "# o  #         o       ### #",
   "#    #                     #",
   "############################"];
----

The `#` characters are used to represent the walls of the
terrarium (and the ornamental rocks lying in it), the `o` characters
represent bugs, and the spaces are, as you might have guessed, empty
space.

(((toString@`toString` method)))
Such a plan array can be used to create a terrarium object. This
object keeps track of the shape and content of the terrarium and lets
the bugs inside move. It has two methods: `toString`, which
converts the terrarium back to a string similar to the plan it was
based on so that you can see what is going on inside it, and
`step`, which allows all the bugs in the terrarium to move one
step, if they so desire.

== Points in Space ==

(((Point@`Point` type)))
The points on the grid will be represented by very simple
objects, based on a constructor named `Point`, which takes two
arguments, the x- and y-coordinates of the point, and produces an
object with `x` and `y` properties. The prototype of this
constructor has a single method called `add`, which takes another point
as an argument and returns a _new_ point whose `x` and `y`
are the sum of the `x` and `y` of the two given points.

[source,javascript]
----
function Point(x, y) {
  this.x = x;
  this.y = y;
}
Point.prototype.add = function(other) {
  return new Point(this.x + other.x, this.y + other.y);
};
----

Apart from the constructor and the method, the `x` and `y`
properties are also part of the interface of this type of objects:
Code that uses point objects may freely retrieve and modify `x`
and `y`.

== Representing the Grid ==

(((object!design)))
When writing objects to implement a certain program, it is not always
very clear which functionality goes where. Some things are best
written as methods of your objects, other things are better expressed
as separate functions, and some things are best implemented by adding
a new type of object. To keep things clear and organized, it is
important to keep the amount of methods and responsibilities that an
object type has as small as possible. When an object does too much, it
becomes a mess and a source of confusion.

I said earlier that the terrarium object will be responsible for storing
its contents and for letting the bugs inside it move. Note
that it _lets_ them move; it doesn't _make_ them move. The
bugs themselves will also be objects, and these objects are
responsible for deciding what they want to do. The terrarium merely
provides the infrastructure that asks them what to do, and if they decide to move, it makes sure this happens.

Storing the grid on which the content of the terrarium is kept can get
quite complex. It has to define some kind of representation, ways to
access this representation, a way to initialize the grid from a
``plan'' array, a way to write the content of the grid to a string for
the `toString` method, and the movement of the bugs on the grid.
It would be nice if part of this could be moved into another object
so that the terrarium object itself doesn't get too big and complex.

Whenever you find yourself about to mix data representation and 
problem-specific code in one data type, don't. Things will be much
clearer when the two are kept separate. In this case, we need to
represent a grid of values, so I wrote a `Grid` type, which
supports the operations that the terrarium will need.

(((array)))(((data structure)))
To store the values on the grid, there are two options. One can use an
array of row arrays and use two lookups to get to a specific point,
like this:

[source,javascript]
----
var grid = [["0,0", "1,0", "2,0"],
            ["0,1", "1,1", "2,1"]];
#textbf~grid[1][2];@
→ "2,1"
----

Or, the values can all be put into a single array. In this case, the
element at `x`,`y` can be found by getting the element at
position `x + y * width` in the array, where `width` is the
width of the grid.

[source,javascript]
----
var grid = ["0,0", "1,0", "2,0",
            "0,1", "1,1", "2,1"];
#textbf~grid[2 + 1 * 3];@
→ "2,1"
----

(((Array@`Array` type)))
I chose the second representation, because it makes it
much easier to initialize the array. `new Array(x)` produces a
new array of length `x`, filled with `undefined` values.


This code defines the `Grid` object, with some basic methods:
(((Grid@`Grid` type)))

[source,javascript]
----
function Grid(width, height) {
  this.width = width;
  this.height = height;
  this.cells = new Array(width * height);
}
Grid.prototype.valueAt = function(point) {
  return this.cells[point.y * this.width + point.x];
};
Grid.prototype.setValueAt = function(point, value) {
  this.cells[point.y * this.width + point.x] = value;
};
Grid.prototype.isInside = function(point) {
  return point.x >= 0 && point.y >= 0 &&
         point.x < this.width && point.y < this.height;
};
Grid.prototype.moveValue = function(from, to) {
  this.setValueAt(to, this.valueAt(from));
  this.setValueAt(from, undefined);
};
----

(((higher-order function)))
We will also need to go over all the elements of the grid to find the
bugs we need to move or to convert the whole thing to a string. To
make this easy, we can use a higher-order function that takes an
action as its argument. We add the method `each` to the prototype of
`Grid`, which takes an `action` function of two arguments.
It calls this function for every point on the grid, giving it the
point object for that point as its first argument and giving it the value that
is on the grid at that point as its second argument.

This higher-order function abstracts a two-dimensional loop into a
single method call:(((for@`for` loop)))

[source,javascript]
----
Grid.prototype.each = function(action) {
  for (var y = 0; y < this.height; y++) {
    for (var x = 0; x < this.width; x++) {
      var point = new Point(x, y);
      action(point, this.valueAt(point));
    }
  }
};
----

The double `for` loop traverses the grid row by row, starting
from the top, and then square by square in each row, starting from the left.
Doing it in this order is useful, because it will make it easier to write a
method that converts the grid to a string---the elements have to
appear in the same order in such a string.

== A Bug's Programming Interface ==

(((interface)))(((bug object (terrarium))))(((action object (terrarium))))
Before we can start to write a `Terrarium` constructor, we will
have to get a bit more specific about these ``bug objects'' that will
be living inside it. Earlier, I mentioned that the terrarium will ask
the bugs what action they want to take. This will work as follows:
Each bug object has an `act` method that, when called, returns
an _action_. An action is an object with a `type` property,
which names the type of action the bug wants to take, for example
`"move"`. For most actions, the action also contains extra
information, such as the direction the bug wants to go.

Bugs are terribly myopic, and thus they can only see the squares
directly around them on the grid. But these they can use to base their
action on. When the `act` method is called, it is given an object
with information about the surroundings of the bug in question. For
each of the eight directions, it contains a property. The property
indicating what is above the bug is called `n` for north,
the one indicating what is above and to the right is called `ne` for
northeast, and so on. To look up the direction these names refer to,
the following dictionary object is useful:

[source,javascript]
----
var directions = new Dictionary(
  {"n":  new Point( 0, -1),
   "ne": new Point( 1, -1),
   "e":  new Point( 1,  0),
   "se": new Point( 1,  1),
   "s":  new Point( 0,  1),
   "sw": new Point(-1,  1),
   "w":  new Point(-1,  0),
   "nw": new Point(-1, -1)});
----

When a bug decides to move, it indicates in which direction it wants
to go by giving the resulting action object a `direction`
property that names one of these directions. We can make a simple,
stupid bug that always just goes south, ``toward the light,'' like
this:(((StupidBug@`StupidBug` type)))

[source,javascript]
----
function StupidBug() {};
StupidBug.prototype.act = function(surroundings) {
  return {type: "move", direction: "s"};
};
----

== The Terrarium Object ==

Now we can start on the `Terrarium` object type. Here's 
its constructor, which takes a plan (an array of strings) as an argument
and initializes its grid:(((Terrarium@`Terrarium` type)))

[source,javascript]
----
var wall = {};

function elementFromCharacter(character) {

  if (character == " ")
    return undefined;
  else if (character == "#")
    return wall;
  else if (character == "o")
    return new StupidBug();
}

function Terrarium(plan) {
  var grid = new Grid(plan[0].length, plan.length);
  for (var y = 0; y < plan.length; y++) {
    var line = plan[y];
    for (var x = 0; x < line.length; x++) {
      grid.setValueAt(new Point(x, y), elementFromCharacter(line.charAt(x)));
    }
  }
  this.grid = grid;
}
----

The `wall` variable holds an object that is used to mark the
location of walls on the grid. Like a real wall, it doesn't do much;
it just sits there and takes up space. The `elementFromCharacter`
function converts a character that is read from the plan into an
actual value to store in the grid.

(((toString@`toString` method)))
The most straightforward method of a terrarium object is
`toString`, which transforms a terrarium into a string. To make
this easier, we mark both the `wall` and the prototype of the
`StupidBug` with a property `character`, which holds the
character that represents them.

[source,javascript]
----
wall.character = "#";
StupidBug.prototype.character = "o";

function characterFromElement(element) {
  if (element == undefined)
    return " ";
  else
    return element.character;
}
----

Now we can use the `each` method of the `Grid` object to
build up a string. But to make the result readable, it would be nice
to have a newline at the end of every row. The x-coordinate of
the positions on the grid can be used to determine when the end of a
line is reached.

[source,javascript]
----
Terrarium.prototype.toString = function() {
  var characters = [];
  var endOfLine = this.grid.width - 1;


  this.grid.each(function(point, value) {
    characters.push(characterFromElement(value));
    if (point.x == endOfLine)
      characters.push("\n");
  });
  return characters.join("");
};
----

When you try this by creating a new terrarium based on the plan
shown before and then calling `toString` on it, you'll get a
string very similar to the plan you put in.

== this and Its Scope ==

(((this@`this` variable)))(((variable!scope)))
(((self@`self` variable)))
When writing a method like `toString` shown earlier, which makes
use of locally defined functions, you will likely need to access the
`this` variable from an inner function at some point. This will
unfortunately not work. Calling a function always results in a new
`this` being defined inside that function, even when it is not
used as a method. Thus, any `this` variable outside of the
function will not be visible.

Sometimes it is straightforward to work around this by storing the
information you need in a variable, like `endOfLine`, which _is_
visible in the inner function. If you need access to the whole `this`
object, you can store that in a variable too. The name `self` (or
`that`) is often used for such a variable.

(((bind@`bind` function)))(((apply@`apply` method)))
But such pointless extra variables can look messy. Another good
solution is to use a function similar to `partial` from
REF{fp}. Instead of adding arguments to a function, this one adds
a `this` object, using it as the first argument to the function's
`apply` method:

[source,javascript]
----
function bind(func, object) {
  return function(){
    return func.apply(object, arguments);
  };
}

var x = [];
var pushX = bind(x.push, x);
pushX("A");
pushX("B");
#textbf~x;@
→ ["A", "B"]
----

This way, you can `bind` an inner function to `this`, and it
will have the same `this` as the outer function.

(((method@`method` function)))
In the expression `bind(x.push, x)`, the name
`x` still occurs twice. Some people prefer this, more
succinct approach to method binding:


[source,javascript]
----
function method(object, name) {
  return function() {
    return object[name].apply(object, arguments);
  };
}
var pushX = method(x, "push");
----

== Animating Life ==

(((simulation)))
We will need `bind` (or `method`) when implementing the
`step` method of a terrarium. This method has to go over all the
bugs on the grid, ask them for an action, and execute the given
action. You might be tempted to use `each` on the grid and just
handle the bugs we come across. But if you do this, when a bug moves
south or east, we will come across it again in the same turn and
allow it to move again.

Instead, we first gather all the bugs into an array and then process
them. This method gathers bugs, or other things that have an
`act` method, and stores them in objects that also contain their
current position:

[source,javascript]
----
Terrarium.prototype.listActingCreatures = function() {
  var found = [];
  this.grid.each(function(point, value) {
    if (value != undefined && value.act)
      found.push({object: value, point: point});
  });
  return found;
};
----

When asking a bug to act, we must pass it an object with information
about its current surroundings. This object will use the direction
names we saw earlier (`"n"`, `"ne"`, and so on) as property
names. Each property holds a string of one character, as returned by
`characterFromElement`, indicating what the bug can see in that
direction.

For this, we'll write a method `listSurroundings` and add it to
the `Terrarium` prototype. It takes one argument, the point at
which the bug is currently standing, and returns an object with
information about the surroundings of that point. When the point is at
the edge of the grid, `#` is shown for the directions that
would bring the bug outside of the grid, so the bug will not try to
move there.

To go over all the possible directions, we'll just use the
`each` method of the `directions` dictionary that we defined
before. This will give us the ``direction point'' objects for those
directions (things like `Point(0, 1)`), which we can add to the
center we were passed in order to get the coordinates we are
interested in.


[source,javascript]
----
Terrarium.prototype.listSurroundings = function(center) {
  var result = {};
  var grid = this.grid;
  directions.each(function(name, direction) {
    var place = center.add(direction);
    if (grid.isInside(place))
      result[name] = characterFromElement(grid.valueAt(place));
    else
      result[name] = "#";
  });
  return result;
};
----

(((interface)))(((private property)))
The two methods defined previously are not part of the external interface
of a `Terrarium` object; they are internal details. Some
languages provide ways to explicitly declare certain methods and
properties ``private'' and signal an error when you try to use them
from outside the object. JavaScript does not, so you will have to rely
on comments to describe the interface to an object. Sometimes it can
be useful to use some kind of naming scheme to distinguish between
external and internal properties, for example by prefixing all
internal ones with an underscore (`_`). This will make
accidental uses of properties that are not part of an object's
interface easier to spot.

Next is one more internal helper method, the one that will ask a bug
for an action and carry it out. It takes a creature and the point at
which the creature is sitting as arguments. For now, it only knows
about the `"move"` action:

[source,javascript]
----
Terrarium.prototype.processCreature = function(creature) {
  var action = creature.object.act(this.listSurroundings(creature.point));
  if (action.type == "move" && directions.contains(action.direction)) {
    var to = point.add(directions.lookup(action.direction));
    if (this.grid.isInside(to) && this.grid.valueAt(to) == undefined)
      this.grid.moveValue(creature.point, to);
  }
  else {
    throw new Error("Unsupported action: " + action.type);
  }
};
----

Note that it checks whether the chosen direction is inside the grid
and empty and ignores it otherwise. This way, the bugs can ask for
any action they like---the action will be carried out only if it is
actually possible. This acts as a layer of insulation between the bugs
and the terrarium and allows us to be less precise when writing the
bugs' `act` methods---for example, the `StupidBug` just
always tries to move south, regardless of any walls that might stand
in its way.


These three internal methods then finally allow us to write the
`step`  method, which gives all bugs a chance to do something (all
elements with an `act` method---we could also give the
`wall` object one if we so desired and make the walls walk).

[source,javascript]
----
Terrarium.prototype.step = function() {
  forEach(this.listActingCreatures(), bind(this.processCreature, this));
};
----

== It Moves ==

Let us make a terrarium and see whether anything happens:

[source,javascript]
----
var terrarium = new Terrarium(thePlan);
terrarium.step();
print(terrarium);
----

If you look closely, you'll notice all the circles are one line below
where they started. Here's a before/after view:

[source,javascript]
----
############################ ############################
#      #    #      o      ## #      #    #             ##
#                          # #                  o       #
#          #####           # #          #####           #
##         #   #    ##     # ##         #   #    ##     #
###           ##     #     # ###           ##     #     #
#           ###      #     # #           ###      #     #
#   ####                   # #   ####                   #
#   ##       o             # #   ##                     #
# o  #         o       ### # #    #       o         ### #
#    #                     # # o  #         o           #
############################ ############################
----

(((toString@`toString` method)))
Wait, how come the previous calls `print(terrarium)` and ends up
displaying the output of our `toString` method?
`print` turns its arguments to strings using the `String`
function. Objects are turned to strings by calling their
`toString` method, so giving your own object types a meaningful
`toString` is a good way to make them readable when printed out.

[source,javascript]
----
Point.prototype.toString = function() {
  return "(" + this.x + "," + this.y + ")";
};
----


== More Life Forms ==

(((hard-coding)))
So, we have a terrarium object in which something is happening. But
who wants a terrarium with just one kind of bug, and a stupid bug at
that? It would be nice if we could add different kinds of bugs.
Fortunately, all we have to do is make the `elementFromCharacter`
function more general. Right now, it contains three cases that are
typed in directly, or _hard-coded_:

[source,javascript]
----
function elementFromCharacter(character) {
  if (character == " ")
    return undefined;
  else if (character == "#")
    return wall;
  else if (character == "o")
    return new StupidBug();
}
----

The first two cases we can leave intact, but the last one is way too
specific. A better approach would be to store the characters and the
corre- sponding bug constructors in a dictionary and look for them
there:

[source,javascript]
----
var creatureTypes = new Dictionary();
creatureTypes.register = function(constructor, character) {
  constructor.prototype.character = character;
  this.store(character, constructor);
};

function elementFromCharacter(character) {
  if (character == " ")
    return undefined;
  else if (character == "#")
    return wall;
  else if (creatureTypes.contains(character))
    return new (creatureTypes.lookup(character))();
  else
    throw new Error("Unknown character: " + character);
}
----

(((method)))
Note how the `register` method, which registers a character type,
is added to `creatureTypes`---this is a dictionary object, but
there is no reason why it shouldn't support an additional method. This
method stores the constructor in the dictionary and makes sure its
`prototype.character` points back at the character so that we
can print it.

`elementFromCharacter` now looks up the character it's given in
`creatureTypes` and raises an exception when it comes across an
unknown character.

(((BouncingBug@`BouncingBug` type)))
Here is a new bug type and the call to register its character in  `creatureTypes`:


[source,javascript]
----
function BouncingBug() {
  this.direction = "ne";
}
BouncingBug.prototype.act = function(surroundings) {
  if (surroundings[this.direction] != " ")
    this.direction = (this.direction == "ne" ? "sw" : "ne");
  return {type: "move", direction: this.direction};
};
creatureTypes.register(BouncingBug, "%");
----

Can you figure out what it does?

The `act` method checks whether the space ahead (where ``ahead''
is  determined by `this.direction`) is empty. If it is not, the
bug turns around, moving diagonally in the other direction until it
hits an obstacle there.

Next up is a bug type called `DrunkBug` that tries to move in a
random direction every turn, never mind whether there is a wall there.

(((random@`random` function)))
To produce ``randomness,'' we can use the function
`Math.random`. Computers are deterministic machines: They always
react in the same way to the input they receive. Thus, they cannot
produce truly random values. However, utilities like
`Math.random` are able to produce a series of numbers that look
random, even though they are in fact the result of some complicated
deterministic computation. The function returns a number between 0 and
1 (0 inclusive, 1 exclusive). To get a whole number instead, we can
use a function like this:(((randomInteger@`randomInteger` function)))

[source,javascript]
----
function randomInteger(below) {
  return Math.floor(Math.random() * below);
}
----

Calling `randomInteger(2)` will return `0` or `1`. The
multiplication ``scales'' up the range of the random number, and
calling `Math.floor` makes sure it becomes a whole number.

To pick a random direction, we will need an array of direction names.
We could of course just type `["n", "ne", ...]`, but that
duplicates information, and duplicated information makes us nervous.
We could also use the `each` method in `directions` to build
the array, which is better already.

(((Dictionary@`Dictionary` type)))
But there is clearly a generality to be discovered here. Getting a
list of the property names in a dictionary sounds like a useful tool
to have, so we add it to the `Dictionary` prototype.

[source,javascript]
----
Dictionary.prototype.names = function() {
  var names = [];
  this.each(function(name, value) {names.push(name);});
  return names;
};

#textbf~directions.names();@
→ ["n", "ne", "e", "se", "s", "sw", "w", "nw"]
----

(((randomElement@`randomElement` function)))
Here, then, is a way to take a random element from an array:

[source,javascript]
----
function randomElement(array) {
  if (array.length == 0)
    throw new Error("The array is empty.");
  return array[Math.floor(Math.random() * array.length)];
}

#textbf~randomElement(["heads", "tails"]);@
→ ???
----

The result is shown as `???`, because we cannot be sure
in advance what the result of that expression will be. In 50% of the
cases, it will be `"heads"`; in the other 50%, it will be
`"tails"`.

And here's the bug itself:(((DrunkBug@`DrunkBug` type)))

[source,javascript]
----
function DrunkBug() {};
DrunkBug.prototype.act = function(surroundings) {
  return {type: "move", direction: randomElement(directions.names())};
};
creatureTypes.register(DrunkBug, "~");
----

You can test this by adding some `%` and `~` characters
to the plan array, and running a terrarium for a few steps. Notice the
bouncing bugs bouncing off the drunk ones? Pure drama.

== A More Lifelike Simulation ==

(((simulation)))
To make life in the terrarium more interesting, we will add to it the
concepts of food and reproduction. Each living thing in the terrarium
gets a new property, `energy`, which is reduced by performing
actions and increased by eating things. When it has enough energy, a
thing can reproduce, generating a new creature of the same kind. To
keep things reasonably simple, the creatures in our terrarium
reproduce asexually, all by themselves.

(((entropy)))
If there are only bugs, wasting energy by moving around and eating
each other, a terrarium will soon succumb to the forces of entropy,
run out of energy, and become a lifeless wasteland. To prevent this
from happening (too quickly, at least), we add lichen to the
terrarium. Lichen do not move; they just use photosynthesis to gather
energy and reproduce.

To make this work, we'll need a terrarium with a different
`processCreature` method. We could just replace the method of
the `Terrarium` prototype, but we have become very attached to
the simulation of the bouncing and drunk bugs, and we would hate to
break our old terrarium.

(((LifeLikeTerrarium@`LifeLikeTerrarium` type)))(((inheritance|()))
A solution is to create a new constructor, `LifeLikeTerrarium`, 
whose  prototype is based on the `Terrarium` prototype but which
has a different  `processCreature` method.

== Inheritance ==

There are a few ways to do this. We could go over the properties of 
`Terrarium.prototype` and add them one by one to
`LifeLikeTerrarium.prototype`. This is easy to do, and in some
cases it is the best solution, but in this case there is a cleaner
way. If we make the old prototype object the prototype of the new
prototype object (you may have to reread that a few times), it will
automatically have all its properties.

(((clone@`clone` function)))(((prototype)))
Unfortunately, JavaScript does not have a straightforward
way to create an object whose prototype is a certain other object. It
is possible to write a function that does this, though, by using the
following trick:

[source,javascript]
----
function clone(object) {
  function OneShotConstructor(){}
  OneShotConstructor.prototype = object;
  return new OneShotConstructor();
}
----

(((LifeLikeTerrarium@`LifeLikeTerrarium` type)))
This function uses an empty one-shot constructor, whose prototype is
the given object. When using `new` on this constructor, it will
create a new object based on the argument object.

[source,javascript]
----
function LifeLikeTerrarium(plan) {
  Terrarium.call(this, plan);
}
LifeLikeTerrarium.prototype = clone(Terrarium.prototype);
LifeLikeTerrarium.prototype.constructor = LifeLikeTerrarium;
----

(((constructor@`constructor` property)))
The new constructor doesn't need to do anything different from the old
one, so it just calls the old one on the `this` object. We also
have to restore the `constructor` property in the new prototype,
or it would claim its constructor is `Terrarium` (which, of
course, is relevant only if we were to make use of this property,
which we don't).

(((repetition (avoiding of))))(((code reuse)))(((polymorphism)))
It is now possible to replace some of the methods of the
`LifeLikeTerrarium` object or add new ones. We have based a new
object type on an old one, which saved us the work of rewriting all
the methods that are the same in `Terrarium` and
`LifeLikeTerrarium`. This technique is called
_inheritance_. The new type inherits the
properties of the old type. In most cases, this means the new type
will still support the interface of the old type, though it might also
support a few methods that the old type does not have. This way,
objects of the new type can be (polymorphically) used in all the
places where objects of the old type could be used.

In most programming languages with explicit support for
object- oriented programming, inheritance is a very straightforward
thing. In JavaScript, the language doesn't really specify a simple way
to do it. Because of this, JavaScript programmers have invented many
different approaches to inheritance, but none of them is quite perfect.
Fortunately, such a broad range of approaches allows a programmer to
choose the most suitable one for the problem at hand and allows
certain tricks that would be utterly impossible in other languages.

At the end of this chapter, we will see a few other ways to implement
inheritance and the issues they have.(((inheritance|))))

== Keeping Track of Energy ==

The new `processCreature` method is a lot more complicated than
the old one---instead of one type of action, it supports five
different types. It uses some helper methods so that it doesn't
become a huge monster of a method:

[source,javascript]
----
LifeLikeTerrarium.prototype.processCreature = function(creature) {
  var energy, action, self = this;
  function dir() {
    if (!directions.contains(action.direction)) return null;
    var target = point.add(directions.lookup(action.direction));
    if (!self.grid.isInside(target)) return null;
    return target;
  }
  
action = creature.object.act(this.listSurroundings(creature.point));

  if (action.type == "move")
    energy = this.creatureMove(creature.object, creature.point, dir());
  else if (action.type == "eat")
    energy = this.creatureEat(creature.object, dir());
  else if (action.type == "photosynthesize")
    energy = -1;
  else if (action.type == "reproduce")
    energy = this.creatureReproduce(creature.object, dir());
  else if (action.type == "wait")
    energy = 0.2;
  else
    throw new Error("Unsupported action: " + action.type);

  creature.object.energy -= energy;
  if (creature.object.energy <= 0)
    this.grid.setValueAt(creature.point, undefined);
};
----

(((self@`self` variable)))
The local `dir` function (using the `self` variable to
access `this`) is used to extract a direction from an action,
doing some error checking on it. If it finds something invalid, it
returns `null`. The helper functions will be written to check
their argument so that actions with invalid directions are simply
ignored.

Each helper returns the amount of energy spent by this action or a
negative number when energy is gained. The code at the end of the
function updates the creature's energy score and removes the creature
from the grid when it runs out of energy.

The action-specific helpers are relatively straightforward:

[source,javascript]
----
LifeLikeTerrarium.prototype.creatureMove = function(creature, from, to) {
  if (to != null && this.grid.valueAt(to) == undefined) {
    this.grid.moveValue(from, to);
    from.x = to.x; from.y = to.y;
  }
  return 1;
};
----

As before, this checks whether the chosen direction is valid, and not
obstructed, and then moves. The one awkward part is that this has to
update the `from` object, because otherwise the code in
`processCreature` that removes dead creatures won't know where to
find this creature anymore.

Eating is not hard either. It locates the meal that the creature has
chosen, checks whether there is actually anything there, and checks whether
this anything has energy (so that creatures don't go around eating
walls), and then it removes the meal from the grid, giving its energy to
the creature.

[source,javascript]
----  
LifeLikeTerrarium.prototype.creatureEat = function(creature, source) {
  var energy = 1;
  if (source != null) {
    var meal = this.grid.valueAt(source);
    if (meal != undefined && meal.energy) {
      this.grid.setValueAt(source, undefined);
      energy -= meal.energy;
    }
  }
  return energy;
};
----

Finally, to reproduce, we again check whether the chosen spot is valid
and empty (a creature has to choose a spot to put its child). If it
is, a new creature of the same type as the parent is created. The
amount of energy the parent will lose for reproducing is twice the
amount of energy the new creature gets (childbearing is not easy). If
the parent does not have that much energy, the child is not put onto
the grid.

[source,javascript]
----
LifeLikeTerrarium.prototype.creatureReproduce = function(creature, target) {
  var energy = 1;
  if (target != null && this.grid.valueAt(target) == undefined) {
    var species = characterFromElement(creature);
    var baby = elementFromCharacter(species);
    energy = baby.energy * 2;
    if (creature.energy >= energy)
      this.grid.setValueAt(target, baby);
  }
  return energy;
};
----

== Adding Plant Life ==

We now have the ``framework'' needed to simulate these more lifelike
creatures. We could put the creatures from the old terrarium into it,
but they would just die after a few turns. So, let's make some new
ones. First we'll make the lichen, which are rather simple. We will use the
character `*` to represent them.

(((Lichen@`Lichen` type)))
This again uses the `randomElement` function introduced when we
wrote the drunk bug. It also defines a `findDirections` function,
which is used to enumerate the directions in which a certain type of
character is being seen by the creature.

[source,javascript]
----
function findDirections(surroundings, wanted) {
  var found = [];
  directions.each(function(name) {
    if (surroundings[name] == wanted)
      found.push(name);
  });
  return found;
}

function Lichen() {
  this.energy = 5;
}
Lichen.prototype.act = function(surroundings) {
  var emptySpace = findDirections(surroundings, " ");
  if (this.energy >= 13 && emptySpace.length > 0)
    return {type: "reproduce", direction: randomElement(emptySpace)};
  else if (this.energy < 20)
    return {type: "photosynthesize"};
  else
    return {type: "wait"};
};
creatureTypes.register(Lichen, "*");
----

Lichen do not grow bigger than 20 energy, or they would get _huge_
when they are surrounded by other lichen and have no room to
reproduce.

== The Herbivore ==

Next up is the `LichenEater`. It starts with an energy of
10, and its behavior can be described like this:

1. When it has an energy of 30 or more and there is room near it, it reproduces.
2. Otherwise, if there are lichen nearby, it eats a random one.
3. Otherwise, if there is space to move, it moves into a random nearby empty square.
4. Otherwise, it waits.

(((LichenEater@`LichenEater` type)))
We'll use the `c` character (Pac-Man) for this creature:

[source,javascript]
----
function LichenEater() {
  this.energy = 10;
}
LichenEater.prototype.act = function(surroundings) {
  var emptySpace = findDirections(surroundings, " ");
  var lichen = findDirections(surroundings, "*");

  if (this.energy >= 30 && emptySpace.length > 0)
    return {type: "reproduce", direction: randomElement(emptySpace)};
  else if (lichen.length > 0)
    return {type: "eat", direction: randomElement(lichen)};
  else if (emptySpace.length > 0)
    return {type: "move", direction: randomElement(emptySpace)};
  else
    return {type: "wait"};
};
creatureTypes.register(LichenEater, "c");
----

== Bringing It to Life ==

(((simulation)))
And that gives us enough elements to try our new terrarium.
Imagine a moody, dark cave, with lichen growing on the walls and
lichen-eating bugs scuttling around on the floor. That's what this
code is trying to express:

[source,javascript]
----
var moodyCave =
  ["############################",
   "#                     ######",
   "#    ***                **##",
   "#   *##**         **  c  *##",
   "#    ***     c    ##**    *#",
   "#       c         ##***   *#",
   "#                 ##**    *#",
   "#   c       #*            *#",
   "#*          #**       c   *#",
   "#***        ##**    c    **#",
   "#*****     ###***       *###",
   "############################"];

var terrarium = new LifeLikeTerrarium(moodyCave);
for (var i = 0; i < 10; i++) {
  for (var j = 0; j < 20; j++)
    terrarium.step();
  print(terrarium);
}
----

The following output shows a typical run of such a terrarium, with
steps of 20 turns between the pictures:

[source,javascript]
----
############################ ############################
#  ******        c    ###### # c  c*****           ######
#  ******     c     c  ***## #    c*****           ****##
#  **##***      c      ***## #  c ##***            ****##
#    ** *         ##    ***# #  c  * *         ##  c ***#
# cc ***          ##c   ***# #      c      c   ##  cc***#
#          c      ##  c ***# #     c       c   ##   ****#
# c         # **c       ***# #   c  c    #   c   *******#
#           #****c    * ***# #*    c c   #     *  ******#
#******     ##****     ****# #*c  c   c  ## c   * ******#
#******    ###*****    **### #**  cc    ###   c   ****###
############################ ############################






############################ ############################
#  c cc   **         c###### #         ***         ######
#        c *           c  ## #         ****            ##
#    ##    *             c## #    ##    **             ##
#    cc  *        ##ccc    # #           *     ##       #
#c                ##  c  cc# #        c        ##     c #
#      c       c c##   ccc # #                 ##       #
#           #      cc  cc  # #           #              #
#           #          c  c# #          c#           c  #
#           ##    c  c c   # #           ##             #
#          ###      c  c ### #          ###       c   ###
############################ ############################

############################ ############################
#         **          ###### #                     ######
#         **              ## #                         ##
#    ##    **             ## #    ##                   ##
#           *     ##       # #                 ##       #
#        c        ##     c # #                 ##       #
#                 ##       # #                 ##       #
#           #              # #           #              #
#          c#           c  # #           #              #
#           ##             # #           ##             #
#          ###       c   ### #          ###           ###
############################ ############################
----

Most of the time, the lichen quickly overgrow a large part of the
terrarium, after which the abundance of food makes the eaters so
numerous that they wipe out all (or nearly all) the lichen and thus
themselves. Ah, tragedies of nature.

== Artificial Stupidity ==

Having the inhabitants of our terrarium go extinct after a few minutes
is kind of depressing. To deal with this, we could teach our
lichen-eaters about long-term sustainable farming. By making them 
eat only if they see at least two lichen nearby, no matter how hungry they
are, they will never exterminate the lichen. This can be done by
changing their `act` method to  eat only when `lichen.length`
is at least 2.

Running the previous `moodyCave` terrarium with this change,
we still usually see the lichen-eaters still go extinct after a while,
because, in a time of starvation, they crawl aimlessly back and forth
through empty space, instead of finding the lichen that is sitting
just a few squares away from them.


Another potential improvement is to reduce the randomness of these
creatures' movement. By always picking a random direction, it will
often move back and forth without getting anywhere. By remembering the
last direction it went, and preferring that direction, the eater will
waste less time and find food faster. Here is the updated
implementation:(((CleverLichenEater@`CleverLichenEater` type)))

[source,javascript]
----
function CleverLichenEater() {
  this.energy = 10;
  this.direction = "ne";
}
CleverLichenEater.prototype.act = function(surroundings) {
  var emptySpace = findDirections(surroundings, " ");
  var lichen = findDirections(surroundings, "*");

  if (surroundings[this.direction] != " " && emptySpace.length > 0)
    this.direction = randomElement(emptySpace);

  if (this.energy >= 30 && emptySpace.length > 0)
    return {type: "reproduce", direction: randomElement(emptySpace)};
  else if (lichen.length > 1)
    return {type: "eat", direction: randomElement(lichen)};
  else if (emptySpace.length > 0)
    return {type: "move", direction: this.direction};
  else
    return {type: "wait"};
};
creatureTypes.register(CleverLichenEater, "c");
----

(((ecosystem)))
When used in the simulation, this new animal survives the moody cave a
bit longer than its simple-minded cousin. If you give it a big enough
world to live in, so that abundance and scarcity occur in parts of the
environment, rather than everywhere at once, the ecosystem even seems
to stay stable.(((terrarium example|))))

